MODULE main

VAR
    -- Posições dos blocos
    pos_a: 0..7;
    pos_b: 0..7;
    pos_c: 0..7;
    pos_d: 0..7;
    
    -- Apoios dos blocos
    on_a: {table, a, b, c, d};
    on_b: {table, a, b, c, d};
    on_c: {table, a, b, c, d};
    on_d: {table, a, b, c, d};

DEFINE
    -- Tamanhos dos blocos
    size_a := 1;
    size_b := 1;
    size_c := 2;
    size_d := 3;
    
    -- Verifica se o bloco está livre (nada sobre ele)
    is_clear_a := on_b != a & on_c != a & on_d != a;
    is_clear_b := on_a != b & on_c != b & on_d != b;
    is_clear_c := on_a != c & on_b != c & on_d != c;
    is_clear_d := on_a != d & on_b != d & on_c != d;

INIT
    -- Estado inicial S0 (sem sobreposições)
    on_a = table & pos_a = 4 &
    on_b = table & pos_b = 5 &
    on_c = table & pos_c = 0 &
    on_d = table & pos_d = 6;

TRANS
    -- Movimento de A (tamanho 1)
    (
        is_clear_a &
        (
            -- A para mesa (sem colisões)
            (next(on_a) = table &
            (next(pos_a) > pos_b | next(pos_a) < pos_b) &
            (next(pos_a) > pos_c + size_c - 1 | next(pos_a) < pos_c) &
            (next(pos_a) > pos_d + size_d - 1 | next(pos_a) < pos_d))
        |
            -- A sobre B (tamanhos iguais: A cabe perfeitamente em B)
            (is_clear_b & next(on_a) = b & next(pos_a) = pos_b)
        |
            -- A sobre C (A cabe em C: 1 <= 2)
            (is_clear_c & next(on_a) = c & 
            next(pos_a) >= pos_c & next(pos_a) + size_a - 1 <= pos_c + size_c - 1)
        |
            -- A sobre D (A cabe em D: 1 <= 3)
            (is_clear_d & next(on_a) = d & 
            next(pos_a) >= pos_d & next(pos_a) + size_a - 1 <= pos_d + size_d - 1)
        )
        &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_c) = pos_c & next(on_c) = on_c &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de B (tamanho 1)
    (
        is_clear_b &
        (
            (next(on_b) = table &
            (next(pos_b) > pos_a | next(pos_b) < pos_a) &
            (next(pos_b) > pos_c + size_c - 1 | next(pos_b) < pos_c) &
            (next(pos_b) > pos_d + size_d - 1 | next(pos_b) < pos_d))
        |
            -- B sobre A (tamanhos iguais)
            (is_clear_a & next(on_b) = a & next(pos_b) = pos_a)
        |
            -- B sobre C (B cabe em C: 1 <= 2)
            (is_clear_c & next(on_b) = c & 
            next(pos_b) >= pos_c & next(pos_b) + size_b - 1 <= pos_c + size_c - 1)
        |
            -- B sobre D (B cabe em D: 1 <= 3)
            (is_clear_d & next(on_b) = d & 
            next(pos_b) >= pos_d & next(pos_b) + size_b - 1 <= pos_d + size_d - 1)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_c) = pos_c & next(on_c) = on_c &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de C (tamanho 2)
    (
        is_clear_c &
        (
            (next(on_c) = table &
            (next(pos_c) > pos_a | next(pos_c) + size_c - 1 < pos_a) &
            (next(pos_c) > pos_b | next(pos_c) + size_c - 1 < pos_b) &
            (next(pos_c) > pos_d + size_d - 1 | next(pos_c) + size_c - 1 < pos_d))
        |
            -- C só pode ir sobre D (C cabe em D: 2 <= 3)
            (is_clear_d & next(on_c) = d & 
            next(pos_c) >= pos_d & next(pos_c) + size_c - 1 <= pos_d + size_d - 1)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de D (tamanho 3 - maior bloco)
    (
        is_clear_d &
        (
            -- D só pode ir para mesa (não cabe em nenhum outro bloco)
            next(on_d) = table &
            (next(pos_d) > pos_a | next(pos_d) + size_d - 1 < pos_a) &
            (next(pos_d) > pos_b | next(pos_d) + size_d - 1 < pos_b) &
            (next(pos_d) > pos_c + size_c - 1 | next(pos_d) + size_d - 1 < pos_c)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_c) = pos_c & next(on_c) = on_c
    );

-- Estado final S7 com FÍSICA RIGOROSA:
-- Torre A→B→C (todos cabem perfeitamente!)
-- D na mesa na posição 3
DEFINE
    GOAL := on_a = b & on_b = c & on_c = table & pos_c = 0 &
            on_d = table & pos_d = 3;

-- Use AG(!GOAL) para ver o caminho detalhado
SPEC AG(!GOAL)
