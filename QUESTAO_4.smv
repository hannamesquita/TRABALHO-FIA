MODULE main

VAR
    -- Posições dos blocos
    pos_a: 0..7;
    pos_b: 0..7;
    pos_c: 0..7;
    pos_d: 0..7;
    
    -- Apoio de cada bloco
    on_a: {table, a, b, c, d};
    on_b: {table, a, b, c, d};
    on_c: {table, a, b, c, d};
    on_d: {table, a, b, c, d};

DEFINE
    -- Tamanhos dos blocos
    size_a := 1;
    size_b := 1;
    size_c := 2;
    size_d := 3;
    
    -- Blocos livres
    is_clear_a := on_b != a & on_c != a & on_d != a;
    is_clear_b := on_a != b & on_c != b & on_d != b;
    is_clear_c := on_a != c & on_b != c & on_d != c;
    is_clear_d := on_a != d & on_b != d & on_c != d;

INIT
    -- Estado inicial
    on_a = table & pos_a = 3 &
    on_b = table & pos_b = 5 &
    on_c = table & pos_c = 0 &
    on_d = table & pos_d = 6;

TRANS
    -- Movimento de A
    (
        is_clear_a &
        (
            (next(on_a) = table &
            (next(pos_a) > pos_b | next(pos_a) < pos_b) &
            (next(pos_a) > pos_c + size_c - 1 | next(pos_a) < pos_c) &
            (next(pos_a) > pos_d + size_d - 1 | next(pos_a) < pos_d))
        |
            (is_clear_b & next(on_a) = b & next(pos_a) = pos_b)
        |
            (is_clear_c & next(on_a) = c & next(pos_a) >= pos_c & next(pos_a) < pos_c + size_c)
        |
            (is_clear_d & next(on_a) = d & next(pos_a) >= pos_d & next(pos_a) < pos_d + size_d)
        )
        &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_c) = pos_c & next(on_c) = on_c &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de B
    (
        is_clear_b &
        (
            (next(on_b) = table &
            (next(pos_b) > pos_a | next(pos_b) < pos_a) &
            (next(pos_b) > pos_c + size_c - 1 | next(pos_b) < pos_c) &
            (next(pos_b) > pos_d + size_d - 1 | next(pos_b) < pos_d))
        |
            (is_clear_a & next(on_b) = a & next(pos_b) = pos_a)
        |
            (is_clear_c & next(on_b) = c & next(pos_b) >= pos_c & next(pos_b) < pos_c + size_c)
        |
            (is_clear_d & next(on_b) = d & next(pos_b) >= pos_d & next(pos_b) < pos_d + size_d)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_c) = pos_c & next(on_c) = on_c &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de C
    (
        is_clear_c &
        (
            (next(on_c) = table &
            (next(pos_c) > pos_a | next(pos_c) + size_c - 1 < pos_a) &
            (next(pos_c) > pos_b | next(pos_c) + size_c - 1 < pos_b) &
            (next(pos_c) > pos_d + size_d - 1 | next(pos_c) + size_c - 1 < pos_d))
        |
            (is_clear_a & next(on_c) = a & next(pos_c) >= pos_a & next(pos_c) < pos_a + size_a)
        |
            (is_clear_b & next(on_c) = b & next(pos_c) >= pos_b & next(pos_c) < pos_b + size_b)
        |
            (is_clear_d & next(on_c) = d & next(pos_c) >= pos_d & next(pos_c) < pos_d + size_d)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de D
    (
        is_clear_d &
        (
            (next(on_d) = table &
            (next(pos_d) > pos_a | next(pos_d) + size_d - 1 < pos_a) &
            (next(pos_d) > pos_b | next(pos_d) + size_d - 1 < pos_b) &
            (next(pos_d) > pos_c + size_c - 1 | next(pos_d) + size_d - 1 < pos_c))
        |
            (is_clear_a & next(on_d) = a & next(pos_d) >= pos_a & next(pos_d) < pos_a + size_a)
        |
            (is_clear_b & next(on_d) = b & next(pos_d) >= pos_b & next(pos_d) < pos_b + size_b)
        |
            (is_clear_c & next(on_d) = c & next(pos_d) >= pos_c & next(pos_d) < pos_c + size_c)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_c) = pos_c & next(on_c) = on_c
    );

-- ========================================
-- PROPRIEDADES NÃO REALIZÁVEIS (IMPOSSÍVEIS)
-- ========================================

-- IMPOSSÍVEL 1: Um bloco estar sobre si mesmo
DEFINE
    IMPOSSIBLE_1 := on_a = a | on_b = b | on_c = c | on_d = d;

-- IMPOSSÍVEL 2: Dois blocos estarem sobre o mesmo bloco na mesma posição
DEFINE
    IMPOSSIBLE_2 := (on_a = c & on_b = c & pos_a = pos_b);

-- IMPOSSÍVEL 3: Ciclo de dependência (A sobre B E B sobre A simultaneamente)
DEFINE
    IMPOSSIBLE_3 := (on_a = b & on_b = a);

-- IMPOSSÍVEL 4: Um bloco estar na mesa E sobre outro bloco ao mesmo tempo
DEFINE
    IMPOSSIBLE_4 := (on_a = table & on_a = b);

-- IMPOSSÍVEL 5: Torre impossível (A sobre B sobre C sobre D sobre A - ciclo)
DEFINE
    IMPOSSIBLE_5 := (on_a = b & on_b = c & on_c = d & on_d = a);

-- ========================================
-- ESPECIFICAÇÕES PARA VERIFICAR
-- ========================================

-- Verifica que NUNCA um bloco fica sobre si mesmo (deve ser TRUE)
SPEC AG(!IMPOSSIBLE_1)

-- Verifica que NUNCA dois blocos ocupam mesma posição sobre mesmo bloco (deve ser TRUE)
SPEC AG(!IMPOSSIBLE_2)

-- Verifica que NUNCA há ciclo A->B->A (deve ser TRUE)
SPEC AG(!IMPOSSIBLE_3)

-- Verifica que NUNCA um bloco está na mesa E sobre outro (deve ser TRUE)
SPEC AG(!IMPOSSIBLE_4)

-- Verifica que NUNCA há ciclo completo (deve ser TRUE)
SPEC AG(!IMPOSSIBLE_5)

-- ========================================
-- OBJETIVO REALIZÁVEL (para comparação)
-- ========================================
DEFINE
    REALIZABLE_GOAL := on_c = table & pos_c = 0 & on_a = table & pos_a = 2;

-- Esta deve ser FALSE (mostrando que é possível atingir)
SPEC AG(!REALIZABLE_GOAL)
