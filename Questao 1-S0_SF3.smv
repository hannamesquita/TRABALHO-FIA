MODULE main

VAR
    -- Posição do canto esquerdo de cada bloco
    pos_a: 0..7;
    pos_b: 0..7;
    pos_c: 0..7;
    pos_d: 0..7;

    -- Em que cada bloco está apoiado (table ou outro bloco)
    on_a: {table, a, b, c, d};
    on_b: {table, a, b, c, d};
    on_c: {table, a, b, c, d};
    on_d: {table, a, b, c, d};

DEFINE
    -- Tamanhos dos blocos
    size_a := 1;
    size_b := 1;
    size_c := 2;
    size_d := 3;

    -- Definição de bloco livre (nada sobre ele)
    is_clear_a := on_b != a & on_c != a & on_d != a;
    is_clear_b := on_a != b & on_c != b & on_d != b;
    is_clear_c := on_a != c & on_b != c & on_d != c;
    is_clear_d := on_a != d & on_b != d & on_c != d;

INIT
    on_a = table & pos_a = 3 &
    on_b = table & pos_b = 5 &
    on_c = table & pos_c = 0 &
    on_d = a & pos_d = 3;

TRANS
    -- Movimento de A
    (
        is_clear_a &
        (
            -- mover A para mesa (sem colisões)
            (next(on_a) = table &
            (next(pos_a) > pos_b | next(pos_a) < pos_b) &
            (next(pos_a) > pos_c + size_c - 1 | next(pos_a) < pos_c) &
            (next(pos_a) > pos_d + size_d - 1 | next(pos_a) < pos_d))
        |
            -- mover A sobre B (qualquer posição que tenha alguma sobreposição)
            (is_clear_b & next(on_a) = b & 
            next(pos_a) >= pos_b & next(pos_a) < pos_b + size_b)
        |
            -- mover A sobre C
            (is_clear_c & next(on_a) = c & 
            next(pos_a) >= pos_c & next(pos_a) < pos_c + size_c)
        |
            -- mover A sobre D
            (is_clear_d & next(on_a) = d & 
            next(pos_a) >= pos_d & next(pos_a) < pos_d + size_d)
        )
        &
        -- os outros blocos não se movem
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_c) = pos_c & next(on_c) = on_c &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de B
    (
        is_clear_b &
        (
            (next(on_b) = table &
            (next(pos_b) > pos_a | next(pos_b) < pos_a) &
            (next(pos_b) > pos_c + size_c - 1 | next(pos_b) < pos_c) &
            (next(pos_b) > pos_d + size_d - 1 | next(pos_b) < pos_d))
        |
            (is_clear_a & next(on_b) = a & 
            next(pos_b) >= pos_a & next(pos_b) < pos_a + size_a)
        |
            (is_clear_c & next(on_b) = c & 
            next(pos_b) >= pos_c & next(pos_b) < pos_c + size_c)
        |
            (is_clear_d & next(on_b) = d & 
            next(pos_b) >= pos_d & next(pos_b) < pos_d + size_d)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_c) = pos_c & next(on_c) = on_c &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de C
    (
        is_clear_c &
        (
            (next(on_c) = table &
            (next(pos_c) > pos_a | next(pos_c) + size_c - 1 < pos_a) &
            (next(pos_c) > pos_b | next(pos_c) + size_c - 1 < pos_b) &
            (next(pos_c) > pos_d + size_d - 1 | next(pos_c) + size_c - 1 < pos_d))
        |
            -- C pode ir sobre qualquer bloco
            (is_clear_a & next(on_c) = a & 
            next(pos_c) >= pos_a & next(pos_c) < pos_a + size_a)
        |
            (is_clear_b & next(on_c) = b & 
            next(pos_c) >= pos_b & next(pos_c) < pos_b + size_b)
        |
            (is_clear_d & next(on_c) = d & 
            next(pos_c) >= pos_d & next(pos_c) < pos_d + size_d)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_d) = pos_d & next(on_d) = on_d
    )

|
    -- Movimento de D
    (
        is_clear_d &
        (
            (next(on_d) = table &
            (next(pos_d) > pos_a | next(pos_d) + size_d - 1 < pos_a) &
            (next(pos_d) > pos_b | next(pos_d) + size_d - 1 < pos_b) &
            (next(pos_d) > pos_c + size_c - 1 | next(pos_d) + size_d - 1 < pos_c))
        |
            -- D pode ir sobre qualquer bloco
            (is_clear_a & next(on_d) = a & 
            next(pos_d) >= pos_a & next(pos_d) < pos_a + size_a)
        |
            (is_clear_b & next(on_d) = b & 
            next(pos_d) >= pos_b & next(pos_d) < pos_b + size_b)
        |
            (is_clear_c & next(on_d) = c & 
            next(pos_d) >= pos_c & next(pos_d) < pos_c + size_c)
        )
        &
        next(pos_a) = pos_a & next(on_a) = on_a &
        next(pos_b) = pos_b & next(on_b) = on_b &
        next(pos_c) = pos_c & next(on_c) = on_c
    );

-- Estado final s_f3: D sobre C na posição 0
DEFINE
    GOAL := on_d = c & pos_d = 0 &
            on_c = table & pos_c = 0 &
            on_a = table & pos_a = 4 &
            on_b = table & pos_b = 5;

-- Use AG(!GOAL) para ver o caminho detalhado como contraexemplo
SPEC AG(!GOAL)
